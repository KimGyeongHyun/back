from sys import stdin
import heapq
# from my_lib.tools import *

# 1) 강의 시작 시간 순서로 정렬된 상태라면
#   강의가 중복되는 순서를 처음부터 차곡차곡 볼 수 있다

# 2) 위의 정렬 상태로 최소 힙에 강의 끝 시간을 넣기
#   제일 일찍 끝나는 시간이 최소 힙에서 pop 된다
#   정리 1: 강의 시작 시간이 최소 힙의 끝나는 시간보다 작을 경우
#       해당 강의는 최소 힙 끝나는 시간에 대해 중첩
#   정리 2: 강의 시작 시간이 최소 힙의 끝나는 시간보다 크거나 같을 경우
#       해당 강의는 중복 없이 넘어가게 된다
#   정리 3: 중첩된 강의 수만큼 강의가 끝나는 최소 시간 갱신이 밀리게 구성할 수 있다
#       정리 1의 경우 최소 시간 갱신이 밀리게 하기 위해 최소 힙을 pop 하지 않는다
#       정리 2의 경우 최소 시간 갱신이 밀리지 않도록 최소 힙을 pop 한다
#       최소 힙이 밀렸을 경우 강의가 끝나는 시간 갱신 없이 새로운 끝나는 강의 시간이 힙에 저장된다
#       최소 힙이 밀리지 않을 경우 강의가 끝나는 시간이 pop 되어 갱신되고 새로운 끝나는 강의 시간이 힙에 저장된다
#       중간 정리:
#           힙의 크기(강의가 끝나는 최소 시간 갱신이 밀린 횟수) 는 중첩된 강의 수라고 볼 수 있다
#
#
#       최소 시간 갱신이 밀려 최소 힙이 증가하는 방법을 사용하면
#       이후에 강의 시간이 중복이 되지 않아도 이전까지 시간이 밀린 만큼 힙의 사이즈가 유지되어 중첩된 강의의 수를 저장할 수 있으며
#       이후 더 많은 강의 시간 중첩이 있을 경우 최소 힙의 갱신을 밀어 중첩된 강의의 수를 갱신할 수 있다

# 추가 정리
# 강의 시작 시간에서 비교를 할 때 몇 번째 강의의 끝 시간이 겹치는지 확인할 필요 없이
# 해당 강의 전 모든 강의에 대해서 강의 끝 시간이 중복되는 강의 갯수만 알면 된다
# 끝 시간이 중복되는 강의의 끝 시간만 모아 최소 힙으로 구성하고
# 강의가 추가됨에 따라 최소 힙을 갱신하는 방법을 사용한 것
# 갱신될 때마다 정렬이 되어야 하고 삽입, 삭제 연산이 많으므로 우선순위 큐 사용

if __name__ == "__main__":

    n = int(stdin.readline())
    l = []
    for _ in range(n):
        l.append(tuple(map(int, stdin.readline().split())))
    l.sort()

    q = []
    heapq.heappush(q, l[0][1])

    for i in range(1, n):
        if l[i][0] < q[0]:
            heapq.heappush(q, l[i][1])
        else:
            heapq.heappop(q)
            heapq.heappush(q, l[i][1])

        # see_heapq(q)

    print(len(q))
    # draw_l_line(l)
