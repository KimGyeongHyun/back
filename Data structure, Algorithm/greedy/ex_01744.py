from sys import stdin

# 1. 음수끼리 곱하면 양수가 된다
# 2. 두 개씩 곱해서 제일 큰 수를 구하려면 제일 큰 수 2개부터 곱해서 차근차근 더해야 한다

# 작동방식  [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]
# 0을 포함한 음수를 모으고 정렬한다       [-5, -4, -3, -2, -1, 0]
# 자연수를 모으고 내림차순으로 정렬한다    [5, 4, 3, 2, 1]
# 앞에서부터 2개씩 묶는다
# [(-5, -4), (-3, -2), (-1, 0)]  /  [(5, 4), (3, 2), 1]
# 묶은 수를 곱해 더한다. 뒤에 남은 수는 따로 더한다.
# [20 + 6 + 0]  /  [20 + 6 + 1]
# 두 배열의 합을 리턴한다     26 + 27 = 53

# 음수 배열
# 음수 배열 내에 0이 없다면 홀수 개의 음수로 인해 남은 음수는 그대로 총합에 더해진다
# [(-5, -4), (-3, -2), -1] -> [20 + 6 + -1] -> 25
# 반면 0이 있다면 홀수 개의 음수로 인해 남은 음수는 0과 곱해진다
# [(-5, -4), (-3, -2), (-1, 0)] -> [20 + 6 + 0] -> 26
# 즉 0이 남은 음수와 곱해지면서 총합을 더 크게 만들어 줄 수 있다

# 예외사항
# 양수 배열에서 마지막으로 곱해서 더해지는 수가 1, 1 이라면
# 곱해서 더하는 대신 그대로 더하는게 총합이 크다
# 1 * 1 = 1  /  1 + 1 = 2


if __name__ == "__main__":
    n = int(stdin.readline())
    l = []
    for _ in range(n):
        l.append(int(stdin.readline()))

    l.sort()    # 정렬
    mid_idx = len(l)    # 양수, 음수 배열 찾기 위한 인덱스
    sum = 0     # 총합

    # 양수가 시작하는 인덱스를 찾음
    for i in range(len(l)):
        if l[i] > 0:
            mid_idx = i
            break

    # 각각의 배열 구성
    m = l[:mid_idx]
    p = l[mid_idx:]
    p.reverse()

    # 음수 배열 총합
    for i in range(0, len(m)-1, 2):
        sum += m[i] * m[i+1]
    if len(m)%2 == 1:
        sum += m[-1]

    # 양수 배열 총합
    for i in range(0, len(p)-1, 2):
        if p[i+1] == 1:     # 예외사항
            sum += p[i] + p[i+1]
        else:
            sum += p[i] * p[i+1]
    if len(p)%2 == 1:
        sum += p[-1]

    print(sum)