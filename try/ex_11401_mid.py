import sys
sys.setrecursionlimit(10**7)
DIV_NUM = 1000000007

# 이항 계수 n, k 가 주어졌을 때 구해야 하는 답은 (n! / (k! * (n-k)!)) % 1000000007
# 팩토리얼을 그대로 쓰면 값이 커져 계산해야 하는 수가 많아지므로 사용할 수 없다 (시간 초과)
# 1000000007 로 나눈 나머지만 구하면 되는데
# 이 때 모듈러 곱셈 분배법칙을 쓰면 계산 중에 불필요하게 숫자를 크게 가져가지 않아도 된다

# 모듈러 연산
# a % b = r

# 모듈러 곱셈 분배법칙
# (a * b) % p = ((a % p) * (b % p)) % p
# 따라서 n! % p 를 구하는 경우
# 모든 팩토리얼 연산마다 모듈러 곱셈 분배법칙을 적용하면
# 결과값을 해치지 않으면서 숫자를 작게 가져갈 수 있다

# 문제에선 (n! / (k! * (n-k)!)) % 1000000007 과 같이 나눗셈이 존재한다
# 하지만 모듈러 나눗셈 분배법칙은 없다
# p 가 소수일 때 나눗셈 분배법칙을 2가지 방법으로 뽑아낼 수 있다 (1000000007은 소수)

# 풀이 1) 모듈러 곱셈 역원을 직접 구한다

# 1. 유클리드 호제법 (최대공약수 빨리 구하기)
# GCD(a, b) = a, b 의 최대공약수
# a, b 의 최대공약수를 구할 때 a = bx + r (x: a//b) 라면
# GCD(a, b) = GCD(b, r) 을 만족함
# GCD(a, b) 파라미터 b 값이 0일 때 a 값이 최대공약수

# 2. 확장 유클리드 알고리즘 (x, y 정수해까지 같이 구함)
# 배주 항등식
#   ax + by = c
#   x, y 가 정수해를 가지기 위해서는 c 가 GCD(a, b) 의 정수배여야 한다
# a, b 의 최대공약수를 구할 때
# 배주 항등식 GCD(a, b) = ax + by 에 대한 x, y 정수해 값을 같이 구하는 알고리즘
# ax + by = g, a = bq + r (q: a//b) 이라 할 때
# 왼쪽 a 에 오른쪽 식을 대입하면 b(qx + y) + rx = g
# 즉 b, r 에 대한 배주 항등식으로 나타낼 수 있다
# b, r 의 배주 항등식을 bx' + ry' = g 로 표현한다면
# x' = qx + y, y' = x, x = y', y = x - qy', q = a//b 라고 볼 수 있다
# 따라서 GCD(b, r) 배주 항등식 정수해에서 GCD(a, b) 배주 항등식 정수해를 도출할 수 있다
# 마지막 GCD 파라미터는 GCD(g, 0) 이며
# x = y', y = x - qy' 를 통해 GCD(a, b) 배주 항등식까지 올라가면서 계산할 수 있다

# ex) 550, 330 배주 항등식 x, y 정수해 찾기
# 최대공약수는 110 이므로 GCD(110, 0) 에 대한 배주 항등식 -> 110x = 110 -> x=1, y=0
# GCD(220, 110) 220x + 110y = ~ 정수 해 구하기
# GCD(110, 0) 의 정수해를 x', y' 라고 하면
# x = y' = 1, y' = x - y * (a//b) = 0 (a 와 b 는 현재 배주 항등식의 계수, a=220, b=110)
# GCD(330, 220) 330x + 220y = ~ 정수 해 구하기
# x = y' = 1, y = x - y * (a//b) = -1
# GCD(550, 330) 550x + 330y = ~ 의 정수 해 구하기
# x = y' = -1, y = x - y * (a//b) = 2
# 즉 550x + 330y = g 배주 항등식의 x, y 정수해는 (-1, 2)

# 3. 모듈러 역원 구하기
# a 의 N 에 대한 모듈러 곱셈 역원 구하기
# ax % N = 1 % N = 1 일 때 x 는 a 의 N 에 대한 모듈러 곱셈의 역원이다
# ax % N = 1 은 ax = kN + 1 이라고 볼 수 있으며 이를 조금 수정하면
# ax + Ny = 1 과 같은 배주 항정식으로 볼 수 있다
# (위의 식이 정수해를 가질 조건은 배주 항정식 조건에 따라
# a, N 의 최대공약수가 1이어야 하므로 a, N 은 서로소여야 한다
# 하지만 문제에서 N 은 소수이고 a 는 모듈러 곱셈 분배법칙 적용으로 인해 N 보다 항상 작으므로
# 해당 문제에선 신경 쓸 필요 없다)
# 위에서 구한 확장 유클리드 알고리즘으로 모듈러 역원인 x 를 구할 수 있다

# 위의 정리를 종합하여 (a / b) % p 를 구한다면 (p 는 소수)
# 모듈러 곱셈 법칙에 의하여
# (a / b) % p = (a * (1/b)) % p = ((a % p) * ((1/b) % p)) % p
# 의 식을 얻을 수 있다

# 풀이 2) 페르마 소정리로 역원을 구한다

# 1. 페르마 소정리
# a 가 정수이고 p 가 소수라면 a 의 p 의 모듈러 곱셈에 대한 역원을 찾을 수 있다
# a**-1 % p = a**(p-2) % p
# 페르마 소정리의 경우 ((a % p) * ((1/b) % p)) % p
# = ((a % p) * (b**(p-2) % p)) % p 의 식을 얻을 수 있다

# 2. 거듭제곱을 구할 때 지수를 반으로 나누는 방식 사용
# 팩토리얼 연산과 마찬가지로 모듈로 곱셈 분배법칙에 따라 큰 수를 날리며 계산
# b**(p-2) 에서 p 는 1000000007 이기 때문에 그냥 실행하면 시간 초과 발생
# 따라서 지수를 반씩 나눠 계산해야 한다
# a**b 가 있을 때
# b 가 짝수라면 a**b = a**(2*(b//2)) = (a**2)**(b//2),
# b 가 홀수라면 a**b = a**(2*(b//2)+1) = a * (a**2)**(b//2) 이다
# b 가 1, 0 일 때 a**b 는 각각 a, 1 이므로 재귀 함수를 사용한다

# a, b 를 구하고 두가지 방법중 하나로 모듈러 곱셈에 대한 역원을 찾은 후 정답을 구한다


def eed(a, b):
    """a, b 의 최대공약수와 ax + by = g 배주 항등식의 (x, y) 정수해 반환"""
    if b == 0:
        return a, 1, 0

    g, x, y = eed(b, a % b)
    return g, y, x - y * (a // b)


def mod_inverse(a):
    """모듈러 연산자가 소수임을 가정하고 a-1 모듈러 역원을 반환"""
    g, a, b = eed(a, DIV_NUM)

    # a, N 이 서로소가 아니라면 모듈러 곱셈 역원을 구할 수 없음
    if g > 1:
        return -1

    # 역원(a)을 구하여 0 ~ DIV_NUM-1 사이에 배치
    return (a + DIV_NUM) % DIV_NUM


def factorial(a):
    """최종 연산이 모듈러 연산임을 가정하고 모듈러 곱셈 분배법칙으로 팩토리얼 값 반환"""
    res = 1

    for i in range(1, a+1):
        res = res * i % DIV_NUM

    return res


def power(a, rep):
    """최종 연산이 모듈러 연산임을 가정하고 모듈러 곱셈 분배법칙으로 거듭제곱 값 반환"""

    if rep == 0:
        return 1
    if rep == 1:
        return a

    mid = power(a, rep // 2)

    if rep % 2 == 0:
        return mid * mid % DIV_NUM
    else:
        return mid * mid * a % DIV_NUM


def bio_co(input_n, input_k, mod):
    """모듈러 곱셈 역원을 구하여 이항 계수 n, k 를 1000000007 로 나눈 나머지 값을 반환"""

    # ((a % p) * ((1/b) % p)) % p
    # first : a % p, second : (1/b) % p
    # answer : (first * second) % p

    first = factorial(input_n)
    b = factorial(input_k) * factorial(input_n - input_k) % DIV_NUM

    if mod == "rev":
        second = mod_inverse(b)         # 역원 직접 구하기
    elif mod == "sm":
        second = power(b, DIV_NUM - 2)  # 페르마 소정리로 역원 구하기
    else:
        return 0

    return first * second % DIV_NUM


if __name__ == "__main__":

    n, k = map(int, sys.stdin.readline().split())

    print(bio_co(n, k, "rev"))
    # print(bio_co(n, k, "sm"))
