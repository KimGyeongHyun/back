import sys
input = sys.stdin.readline

# dfs 로 풀기엔 M**N 의 시간복잡도를 가지므로 시간초과 발생
# dp 를 사용, 중간 지점을 저장하며 진행해야 함

# dp key: 무게, value: 최대 가치 라고 설정
# 하지만 dp 끼리 합치려고 하면 하면 문제가 발생
# 무게 2, 3 일 때의 최대 가치가 있을 때 두 무게의 최대 가치의 합은 무게 5의 최대 가치와 다를 수 있음
# 무게 2, 3 의 최대 가치가 같은 물건을 가지고 있을 수 있기 때문
# 따라서 dp 를 갱신할 땐 dp 끼리 합치는 것이 아닌 물건을 하나씩 합치는 방식 사용
# 계산 과정에 있어서 dp 는 항상 해당 무게에서의 최대 가치를 가지고 있어야 함

# dp 에 최대 가치가 갱신되어 있다고 가정, 물건을 하나 추가할 때에도 dp 갱신을 유지하는 방법
# 현재 dp 에 해당 물건 전까지의 모든 무게에 대한 최대 가치가 갱신되어 있다
# 특정 무게에서 해당 물건을 추가하면서 dp 를 갱신할 때는
# '기존 해당 무게에서의 최대 가치(dp)' 와
# '해당 물건의 가치' + '비교할 무게에서 해당 물건의 무게를 뺀 무게의 최대 가치(dp)' 중
# 큰 값을 dp 에 저장하면 된다
# 그러면 기존 최대 가치에서 물건을 하나 추가한 최대 가치를 구할 수 있다

# dp 를 갱신할 땐 낮은 무게의 dp 를 사용하기 때문에
# dp 를 설정할 때 무게를 오름차순으로 갱신한다면
# 이전 dp 의 값이 해당 물건을 추가하는 도중 갱신되어 dp 가 훼손된다
# 내림차순으로 dp 를 갱신하면 낮은 무게의 dp 가 훼손되지 않고 정상적으로 갱신할 수 있다

if __name__ == "__main__":
    n, k = map(int, input().split())    # 물건 갯수, 배낭 최대 무게
    l = []      # 물건의 무개, 물건의 가치 튜플 형식 저장
    dp = [0 for _ in range(k + 1)]  # key: 무게, value: 최대 가치
    for _ in range(n):
        l.append(tuple(map(int, input().split())))

    # 물건의 갯수만큼 반복
    # i 는 물건
    for i in range(n):
        # j 는 무게
        # i 이전의 물건까지 모든 무게에 대한 최대 가치가 dp 에 저장되어 있다
        # i 물건을 추가하면서 dp 를 갱신한다
        for j in range(k, l[i][0]-1, -1):   # 무게 내림차순으로 dp 갱신
            dp[j] = max(dp[j], dp[j-l[i][0]]+l[i][1])

    print(dp[k])

